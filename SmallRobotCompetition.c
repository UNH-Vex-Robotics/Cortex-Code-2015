#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    PowerExpander,  sensorAnalog)
#pragma config(Sensor, in6,    RightLineFollow,      sensorLineFollower)
#pragma config(Sensor, in7,    MiddleLineFollow,     sensorLineFollower)
#pragma config(Sensor, in8,    LeftLineFollow,       sensorLineFollower)
#pragma config(Sensor, dgtl4,  PusherRightEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  PusherLeftEncoder,  sensorQuadEncoder)
#pragma config(Sensor, dgtl10, LeftRearBumper,  sensorNone)
#pragma config(Sensor, dgtl11, RightRearBumper, sensorNone)
#pragma config(Sensor, dgtl12, PusherHomeLimit, sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,  PusherRightMotor,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,  RightDriveMotorFront,    tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port3,  RightDriveMotorMiddle,   tmotorVex393_MC29, openLoop, reversed, driveRight, encoderPort, I2C_1)
#pragma config(Motor,  port4,  RightDriveMotorRear,     tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port5,  RightIntake,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,  LeftDriveMotorFront,     tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port7,  LeftDriveMotorMiddle,    tmotorVex393_MC29, openLoop, driveLeft, encoderPort, I2C_2)
#pragma config(Motor,  port8,  LeftDriveMotorRear,      tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port9,  LeftIntake,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10, PusherLeftMotor,      tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// left drive motor encoder I2C #FIXME
// right drive motor encoder I2C #FIXME

#pragma platform(VEX)

// Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(45)
#pragma userControlDuration(75)

#include "Vex_Competition_Includes.c"   // Main competition background code...do not modify!

#include "smallbot_control.h"

void pre_auton() {
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;
}

task autonomous() {

	int left = motor_get_left_encoder();
	int right = motor_get_right_encoder();

	motor_set(100,100);

	int dist = inches_to_drive_encoder(34);

	//move forward a set distance and then stop
	while (true){
		int newleft = motor_get_left_encoder();
		int newright = motor_get_right_encoder();

		if (((newleft - left) > dist) && ((newright - right) > dist))
			break;
	}

	motor_set(0,0);

	left = motor_get_left_encoder();
	right = motor_get_right_encoder();

	dist = degrees_to_drive_encoder(90);

	motor_set(100,-100);

	//turn right a certain degree and then stop to release balls to big bot
	while (true){
		int newleft = motor_get_left_encoder();
		int newright = motor_get_right_encoder();

		if (((newleft - left) > dist) && ((newright - right) < (-dist)))
			break;
	}

	motor_set(0,0);

	left = pusher_get_left_encoder();
	right = pusher_get_right_encoder();

	//turn on pusher and intake
	intake_set(INTAKE_OUT_SPEED);
	pusher_set(PUSHER_OUT_SPEED);

	//push out all 4 balls for big bot to pull in
	while (true){
		int newleft = pusher_get_left_encoder();
		int newright = pusher_get_right_encoder();

		if (((newleft - left) > PUSHER_ENC_DIST_THRESH) && ((newright - right) < (-PUSHER_ENC_DIST_THRESH)))
			break;
	}

	//shut off intake
	//reverse pusher to initial position
	intake_set(INTAKE_OFF_SPEED);
	pusher_set(PUSHER_IN_SPEED);

	while(!pusher_get_home_switch());

	left = motor_get_left_encoder();
	right = motor_get_right_encoder();

	motor_set(-100,100);

	dist = degrees_to_drive_encoder(150);

	//turn left to face new pile of balls on field
	while (true){
		int newleft = motor_get_left_encoder();
		int newright = motor_get_right_encoder();

		if (((newleft - left) < (-dist)) && ((newright - right) > dist))
			break;
	}

	motor_set(100,100);

	left = motor_get_left_encoder();
	right = motor_get_right_encoder();

	dist = inches_to_drive_encoder(3);

	//move forward a set distance and then stop
	while (true){
		int newleft = motor_get_left_encoder();
		int newright = motor_get_right_encoder();

		if (((newleft - left) > dist) && ((newright - right) > dist))
			break;
	}

	motor_set(0,0);

	//turn on intake and gather balls (at least 2)
	intake_set(INTAKE_IN_SPEED);

	left = motor_get_left_encoder();
	right = motor_get_right_encoder();

	motor_set(-100,100);

	dist = degrees_to_drive_encoder(205);

	//turn left a certain distance to give balls to big bot
	while (true){
		int newleft = motor_get_left_encoder();
		int newright = motor_get_right_encoder();

		if (((newleft - left) < (-dist)) && ((newright - right) > dist))
			break;
	}

	//left = motor_get_left_encoder();
	//right = motor_get_right_encoder();

	//motor_set(100,100);

	////drive forward towards wall until reaches point to turn left again
	//while (true){
	//	int newleft = motor_get_left_encoder();
	//	int newright = motor_get_right_encoder();

	//	if (((newleft - left) > dist) && ((newright - right) > dist))
	//		break;
	//}

	//left = motor_get_left_encoder();
	//right = motor_get_right_encoder();

	//motor_set(-100,100);

	////turn left to travel towards intake of big bot to release balls again
	//while (true){
	//	int newleft = motor_get_left_encoder();
	//	int newright = motor_get_right_encoder();

	//	if (((newleft - left) < (-dist)) && ((newright - right) > dist))
	//		break;
	//}

	left = motor_get_left_encoder();
	right = motor_get_right_encoder();

	motor_set(0,0);
	intake_set(INTAKE_OUT_SPEED);
	pusher_set(PUSHER_OUT_SPEED);

	//push out any balls for big bot to pull in
	while (true){
		int newleft = pusher_get_left_encoder();
		int newright = pusher_get_right_encoder();

		if (((newleft - left) > PUSHER_ENC_DIST_THRESH) && ((newright - right) < (-PUSHER_ENC_DIST_THRESH)))
			break;
	}

	intake_set(INTAKE_OFF_SPEED);
	pusher_set(PUSHER_IN_SPEED);

	while(!pusher_get_home_switch());

	left = motor_get_left_encoder();
	right = motor_get_right_encoder();

	motor_set(100,-100);

	dist = degrees_to_drive_encoder(90);

	//turn right until it faces wall to head back
	while (true){
		int newleft = motor_get_left_encoder();
		int newright = motor_get_right_encoder();

		if (((newleft - left) > dist) && ((newright - right) < (-dist)))
			break;
	}

	left = motor_get_left_encoder();
	right = motor_get_right_encoder();

	motor_set(100,100);

	dist = inches_to_drive_encoder(30);

	//drive forward until time to turn left towards big bot
	while (true){
		int newleft = motor_get_left_encoder();
		int newright = motor_get_right_encoder();

		if (((newleft - left) > dist) && ((newright - right) > dist))
			break;
	}

	left = motor_get_left_encoder();
	right = motor_get_right_encoder();

	motor_set(-100,100);

	dist = degrees_to_drive_encoder(90);

	//turn left to head towards back of big bot
	while (true){
		int newleft = motor_get_left_encoder();
		int newright = motor_get_right_encoder();

		if (((newleft - left) < (-dist)) && ((newright - right) > dist))
			break;
	}

	left = motor_get_left_encoder();
	right = motor_get_right_encoder();

	motor_set(100,100);

	dist = inches_to_drive_encoder(25);

	//drive forward until reaches position at back of big bot
	while (true){
		int newleft = motor_get_left_encoder();
		int newright = motor_get_right_encoder();

		if (((newleft - left) > dist) && ((newright - right) > dist))
			break;
	}

	left = motor_get_left_encoder();
	right = motor_get_right_encoder();

	motor_set(100,-100);

	dist = degrees_to_drive_encoder(90);

	//turn right until back of small bot is facing back of big bot
	while (true){
		int newleft = motor_get_left_encoder();
		int newright = motor_get_right_encoder();

		if (((newleft - left) > dist) && ((newright - right) < (-dist)))
			break;
	}

	left = motor_get_left_encoder();
	right = motor_get_right_encoder();

	motor_set(-100,-100);

	//drive in reverse until bumper switches hit big bot
	while (true){
		if ((bumperswitch_get_left() && bumperswitch_get_right())
			break;
	}

	motor_set(0,0);

}


task usercontrol() {
	while (true) {
		// Drive motors
		motor_set(vexRT[Ch2], vexRT[Ch3]);

		// Pusher
		pusher_set(vexRT[Btn5U] * PUSHER_OUT_SPEED + vexRT[Btn5D] * PUSHER_IN_SPEED);

		// Intake
		intake_set(vexRT[Btn6U] * INTAKE_IN_SPEED + vexRT[Btn6D] * INTAKE_OUT_SPEED);

	}
}

#include "smallbot_control.c"
