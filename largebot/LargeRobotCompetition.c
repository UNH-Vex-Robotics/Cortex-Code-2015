#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in2,    BallSensor,     sensorReflection)
#pragma config(Sensor, dgtl1,  LiftSonar,      sensorNone)
#pragma config(Sensor, dgtl3,  WinchRaised,    sensorTouch)
#pragma config(Sensor, dgtl4,  WinchEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  Shooter,        sensorDigitalOut)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_5,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_6,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           WinchLeft,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           Belt,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           FlyLeft1,      tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port4,           FlyLeft2,      tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port5,           FlyLeft3,      tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port6,           FlyRight3,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_6)
#pragma config(Motor,  port7,           FlyRight2,     tmotorVex393_MC29, openLoop, encoderPort, I2C_5)
#pragma config(Motor,  port8,           FlyRight1,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port9,           IntakeFunnel,  tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          WinchRight,    tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(45)
#pragma userControlDuration(75)

#include "largebot_control.h"
#include "largebot_autonomy.h"
#include "shooter.h"

void pre_auton() {
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

}

task mikec_autonomous() {
	shooter_motor_set(SHOOTER_SPEED);
	belt_set(BELT_SPEED); //Belt on
	intake_set(INTAKE_SPEED); // Intake on
	while (true) {
		if( is_ball_ready()== 0 ) //If no ball in place
		{
			set_pneumatics(SHOOTER_IN); //Don't shoot
		}
		else //If ball in place
		{
			set_pneumatics(SHOOTER_OUT); //Shoot
		}

		if(smallbot_lift_ready()==1) //If Small Bot in place
		{
			winch_down_up(); //Extend winch to full length, then retract
		}
		// 6u -> shooter
		/*
		7u shooter start
		7d shooter stop
		7r decrese speed (by 1)
		7l increase speed (by 1)

		8u hold winch up
		8d hold winch dpwm

		5u toggle belts + intake on
		5d toggle belts + intake reverse
		*/
	}
}

task autonomous() {
	int shots_taken = 0;

	intake_set(-INTAKE_SPEED);
	belt_set(BELT_SPEED);

	shooter_set_target_speed(84);
	shooter_motor_set(84);

	while (true) {
		shots_taken += auto_shoot();
	}
}

task usercontrol() {
	int shots_taken = 0;

	shooter_set_target_speed(84);
	shooter_motor_set(84);

	while (true) {
		shots_taken += auto_shoot();
		// 6u -> shooter
		if(vexRT[Btn6U])
			set_pneumatics(true); // NOTE !!! THIS WILL NOT PLAY NICE WITH THE auto_shoot function!!! You have been warned

		shooter_increment_speed(vexRT[Btn7R]); // NOTE !!! THIS WILL NOT PLAY NICE WITH THE auto_shoot function!!! You have been warned
		shooter_decrement_speed(vexRT[Btn7L]); // NOTE !!! THIS WILL NOT PLAY NICE WITH THE auto_shoot function!!! You have been warned

		if(vexRT[Btn7U])
			shooter_motor_set(shooter_get_target_speed());
		else if(vexRT[Btn7U])
			shooter_motor_set(0);

		winch_set(vexRT[Btn8U] * -WINCH_UP_SPEED + vexRT[Btn8D] * WINCH_UP_SPEED); // yes, this does NOT ues WINCH_DOWN_SPEED, because then there would be a posibilty that both buttons -> movement

		if(vexRT[Btn5U] || vexRT[Btn5D]){
			belt_set(vexRT[Btn5U] * BELT_SPEED + vexRT[Btn5D] * -BELT_SPEED);
			intake_set(vexRT[Btn5U] * INTAKE_SPEED + vexRT[Btn5D] * -INTAKE_SPEED);
		}
	}
}

#include "largebot_control.c"
#include "largebot_autonomy.c"
#include "shooter.c"
